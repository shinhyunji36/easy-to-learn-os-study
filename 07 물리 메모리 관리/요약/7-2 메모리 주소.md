# 7-2 메모리 주소

## 32bit CPU와 64bit CPU
- CPU의 비트는 한번에 다룰 수 있는 데이터의 최대 크기를 의미
- CPU 내부 부품은 모두 이 비트를 기준으로 제작된다. 
- CPU의 비트는 메모리 주소 공간(address space)의 크기와도 연관
  - ex. 32bit CPU는 한번에 다룰 수 있는 데이터의 최대 크기가 32bit


- 32bit CPU 내의 레지스터 크기는 전부 32bit
- 산술논리 연산장치도 32bit를 처리할 수 있도록 설계된다. 
- 또한 데이터를 전송하는 각종 버스의 크기(대역폭)도 32bit

- 메모리 주소의 범위가 $0$~$2^{32}-1$, 총 개수가 $2^{32}$개 이다. 
- 이를 16진수로 나타내면 00000000~FFFFFFFF이며 총 크기는 $2^{32}$B, 약 4GB이다.
  - 따라서 32bit CPU컴퓨터는 메모리를 최대 4GB까지 사용할 수 있다.


- 몇 비트 CPU든 상관 없이 컴퓨터에는 메모리가 설치되며 각 메모리 주소 공간이 있는데 이를 **물리 주소 공간**(physical address space)라고 한다.
- 물리 주소 공간은 하드웨어 입장에서 바라본 주소 공간으로 컴퓨터마다 그 크기가 다르다.
- 이와 반대로 사용자 입장에서 바라본 주소 공간은 **논리 주소 공간**(logical address space)라고 한다.


## **절대 주소와 상대 주소**
### **메모리 영역의 구분**
- ex. 단순 메모리 구조(한 번에 한 가지 일만 처리하는 일괄 처리 시스템에서 볼 수 있는 메모리 구조)
- 메모리 관리자는 이런 메모리를 운영체제 영역과 사용자 영역으로 나누어 관리 한다. 
- 운영체제는 시스템을 관리하는 중요한 역할을 하기 때문에, 사용자가 운영체제를 침범하지 못하도록 분리하여 관리
  - ex. `0~999`번지의 메모리 주소 공간에서 운영체제가 `0~359`번지를 사용하고, 사용자가 `360~999`번지를 사용
  ![image](https://user-images.githubusercontent.com/74661937/194737170-edbd5645-86f5-4d5b-954a-ed79f12f3d07.png)


- 사용자 프로세스는 운영체제 영역을 피해서 메모리에 적재된다. 
  - 운영체제의 영역이 399번지까지 사용한다면, 사용자 프로세스가 400번지부터 적재되어야 한다.
  - 그런데 이렇게 사용자 프로세스가 운영체제 크기에 따라 매번 적재되는 주소가 달라지는 것은 매우 번거로운 일. 
    - 따라서 이를 개선하려 사용자 프로세스를 메모리 최상위부터 사용하는 방법이 있다. (ex. 999번지부터 내려오면서 사용하는 것.)
    - 운영체제 크기에 상관 없이 사용자 영역의 시작점을 결정할 수 있지만, 메모리를 거꾸로 사용하기 위해 주소를 변경하는 일이 복잡하기 때문에 잘 쓰이지 않는다고 한다.
    ![image](https://user-images.githubusercontent.com/74661937/194737186-c33b3b4a-af20-46af-980a-65651b5234a8.png)


- 사용자 영역이 운영체제 영역으로 침범하는 것을 막기 위해 하드웨어인 **CPU 내에 있는 경계 레지스터**의 도움이 필요하다.
  - 경계 레지스터는 운영체제 영역과 사용자 영역 경계 지점의 주소를 가진 레지스터이다. 
  - 메모리 관리자는 사용자가 작업 요청을 할 때마다 경계 레지스터의 값을 벗어나는지 검사하고, 만약 벗어나는 작업을 요청했다면 작업을 요청하는 프로세스를 종료한다.
  ![image](https://user-images.githubusercontent.com/74661937/194737205-0bb7d01b-7f0f-4ea9-8723-fb6cc82a222e.png)



### **절대 주소와 상대 주소의 개념**
- **절대 주소**
  -  실제 물리 주소
  -  메모리 관리자 입장에서 바라본 주소
  -  메모리 주소 레지스터가 사용하는 주소로, 컴퓨터에 꽂힌 램 메모리의 실제 주소
  -  **물리 주소 공간**
  - ex. 사용자 프로세스가 메모리의 사용자 영역 400번지에 올라왔다고 가정
    - 컴파일 방식을 사용하는 프로그램의 경우, 컴파일 시 변수의 주소를 0번지부터 배정한다. 
    - 컴파일 할 당시에는 변수가 메모리의 어느 위치에 올라가는지 알 수 없기 때문에 0번지부터 배정하고 실제로 실행할 때 주소를 조정
    - 만약 사용자 프로세스가 메모리의 400번지에 올라간다면, 프로세스 내 변수의 주소에 400을 더하는데, 이 때 400번지는 **절대 주소**(absolute address) 이다. 

- **상대 주소**: 
  - 사용자 영역이 시작되는 번지를 0번지로 번경하여 사용하는 주소 지정 방식.
  - 사용자 프로세스 입장에서 바라본 주소
  - 절대 주소와 관계 없이 항상 0부터 시작
  - 상대 주소를 사용하면, 프로세스 입장에서 상대 주소가 사용할 수 없는 영역의 위치를 알 필요 없다.
  - 주소가 항상 0번지 부터 시작하기 때문에 편리하다.
  - **논리 주소 공간**

  ![image](https://user-images.githubusercontent.com/74661937/194737214-007698d2-8e3f-4baa-9715-9bda862116fc.png)
  ![image](https://user-images.githubusercontent.com/74661937/194737216-15cd6d3b-805f-4410-b645-0fa887bb29dd.png)

  <br>
  <br>
  

### **상대 주소를 절대 주소로 변환하는 과정**
- 메모리 접근 시, 절대 주소를 사용하면 특별한 변환 과정 없이 작업을 할 수 있다.
- 반면, 상대주소를 사용하면 상대 주소를 실제 메모리 내 물리 주소(절대 주소)로 변환해야 한다.
- 변환 과정
  - 프로세스 실행 동안 메모리 관리자가 빠르게 처리
  - 사용자 프로세스가 상대 주소를 사용해 메모리에 접근할 때마다 상대 주소값에 **재배치 레지스터** 값을 더해 절대 주소를 구한다.
  - 재배치 레지스터는 주소 변환의 기본이 되는 주소값을 가진 레지스터로, 메모리에서 사용자 영역의 시작 주소값이 저장된다
  ![image](https://user-images.githubusercontent.com/74661937/194737224-1657554d-7bee-488c-94c2-ce34dce118b5.png)
